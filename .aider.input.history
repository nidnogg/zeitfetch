
# 2025-03-20 01:49:17.947098
+Y

# 2025-03-20 01:49:23.649318
+:cq

# 2025-03-20 01:52:43.127949
+ok i need you to check this current PR. let me know how it looks, what it proproses to do.

# 2025-03-20 02:24:50.231834
+/ask

# 2025-03-20 02:25:03.571068
+here's output of diff head. diff --git a/.gitignore b/.gitignore
+index 0c7ab5a..e141707 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -10,3 +10,4 @@
+ 
+ # These are backup files generated by rustfmt
+ **/*.rs.bk
++.aider*
+diff --git a/Cargo.toml b/Cargo.toml
+index 255020b..0df86fd 100644
+--- a/Cargo.toml
++++ b/Cargo.toml
+@@ -1,6 +1,6 @@
+ [package]
+ name = "zeitfetch"
+-version = "0.1.14"
++version = "0.1.15"
+ edition = "2021"
+ authors = ["Henrique V (nidnogg)"]
+ description = "Instantaneous snapshots of cross-platform system information"
+@@ -15,7 +15,6 @@ readme = "README.md"
+ home = "0.5.3"
+ lazy_static = "1.4.0"
+ phf = { version = "0.11.2", features = ["macros"] }
+-prettytable-rs = "^0.10"
+ regex = "1.7.3"
+ serde = { version = "1.0.159", features = ["derive"] }
+ serde_json = "1.0.95"
+@@ -23,7 +22,10 @@ strum = "0.25.0"
+ strum_macros = "0.25.3"
+ sysinfo = "0.29.11"
+ termsize = "0.1.8"
++terminal_size = "0.4.1"
+ unicode-segmentation = "1.10.1"
++unicode-width = "0.2.0"
++
+ 
+ [target.'cfg(windows)'.dependencies]
+ winapi = { version = "0.3.9", features = ["processenv"] }
+diff --git a/src/ansi.rs b/src/ansi.rs
+index 6b82fae..f0926e3 100644
+--- a/src/ansi.rs
++++ b/src/ansi.rs
+@@ -2,7 +2,7 @@
+ /// graphics past the truncation point.
+ pub fn truncate(s: &str, n: usize) -> String {
+     use unicode_segmentation::UnicodeSegmentation;
+-
++    use unicode_width::UnicodeWidthStr;
+     #[derive(Debug, PartialEq, Eq)]
+     enum State {
+         Normal,
+@@ -12,36 +12,47 @@ pub fn truncate(s: &str, n: usize) -> String {
+ 
+     use State::*;
+ 
+-    let mut count = 0;
++    let mut visible_width = 0;
+     let mut state = Normal;
+     let mut out = String::new();
++    let mut current_ansi = String::new();
+ 
+     for g in s.graphemes(true) {
+         match state {
+             Normal => {
+                 if g == "\x1b" {
+                     state = Ansi;
++                    current_ansi.clear();
++                    current_ansi.push_str(g);
+                 } else {
+-                    count += 1;
+-                    if count > n {
++                    let char_width = g.width();
++                    if visible_width + char_width > n {
+                         state = Final;
+                         continue;
+                     }
++                    visible_width += char_width;
++                    out.push_str(g);
+                 }
+             }
+             Ansi => {
++                current_ansi.push_str(g);
+                 if g == "m" {
++                    out.push_str(&current_ansi);
+                     state = Normal;
+                 }
+             }
+             Final => {
+-                if g != "\x1b" {
+-                    continue;
++                if g == "\x1b" {
++                    state = Ansi;
++                    current_ansi.clear();
++                    current_ansi.push_str(g);
+                 }
+-                state = Ansi;
+             }
+         }
+-        out.push_str(g)
++    }
++
++    if state == Ansi {
++        out.push_str("\x1b[0m");
+     }
+ 
+     out
+diff --git a/src/main.rs b/src/main.rs
+index f418df7..8779bd5 100644
+--- a/src/main.rs
++++ b/src/main.rs
+@@ -1,12 +1,15 @@
+-use prettytable::{format, row, Table};
+ use std::str;
+ use sysinfo::{System, SystemExt};
++// use prettytable::{format, row, Table};
+ 
+ mod ansi;
+ mod cli;
+ mod logo;
+ mod platform_util;
+ mod scanner;
++mod table;
++
++use crate::table::{format, Table};
+ 
+ fn main() -> Result<(), Box<dyn std::error::Error>> {
+     let ctx = cli::Ctx::new();
+@@ -30,7 +33,7 @@ fn generate_info(ctx: &cli::Ctx) -> Result<(), Box<dyn std::error::Error>> {
+     let logo_col = logo.unwrap_or_else(|| "".into());
+ 
+     let mut table = Table::new();
+-    table.set_format(*format::consts::FORMAT_CLEAN);
++    table.set_format(format::consts::FORMAT_CLEAN);
+ 
+     // Check ctx and generate according tables
+     if ctx.args.no_logo {
+diff --git a/src/scanner.rs b/src/scanner.rs
+index 18cf57b..f57173b 100644
+--- a/src/scanner.rs
++++ b/src/scanner.rs
+@@ -132,6 +132,7 @@ pub fn get_sys_name(sys: &System) -> Option<String> {
+                     stdin.write_all(&buf).unwrap();
+                 }
+             }
++            let _ = cmd_sw_vers.wait();
+             let res = cmd_grep.wait_with_output().unwrap().stdout;
+             let sys_friendly_num = &String::from_utf8(res).unwrap()[16..];
+             let sys_friendly_num_no_whitespace = &sys_friendly_num[..sys_friendly_num.len() - 1];
+diff --git a/src/table.rs b/src/table.rs
+new file mode 100644
+index 0000000..5298d19
+--- /dev/null
++++ b/src/table.rs
+@@ -0,0 +1,221 @@
++use crate::ansi;
++
++#[derive(Clone)]
++pub struct Table {
++    rows: Vec<Row>,
++    format: TableFormat,
++}
++
++#[derive(Clone)]
++pub struct Row {
++    cells: Vec<Cell>,
++}
++
++#[derive(Clone)]
++pub struct Cell {
++    content: String,
++    padding: (usize, usize),
++}
++
++#[derive(Clone)]
++pub struct TableFormat {
++    column_separator: &'static str,
++    row_separator: &'static str,
++    borders: Borders,
++}
++
++#[derive(Clone)]
++pub struct Borders {
++    internal_h: bool,
++}
++
++pub mod format {
++    use super::*;
++
++    pub mod consts {
++        use super::*;
++
++        pub static FORMAT_CLEAN: &TableFormat = &TableFormat {
++            column_separator: "",
++            row_separator: "",
++            borders: Borders { internal_h: false },
++        };
++    }
++}
++#[macro_export]
++macro_rules! row {
++    ($($x:expr),* $(,)?) => {
++        $crate::table::Row::new(vec![
++            $(
++                $crate::table::Cell::new($x)
++            ),*
++        ])
++    };
++}
++
++impl Table {
++    pub fn new() -> Self {
++        Table {
++            rows: Vec::new(),
++            format: format::consts::FORMAT_CLEAN.clone(),
++        }
++    }
++
++    pub fn set_format(&mut self, format: &TableFormat) {
++        self.format = format.clone();
++    }
++
++    pub fn add_row(&mut self, row: Row) {
++        self.rows.push(row);
++    }
++
++    pub fn print<W: std::io::Write>(&self, writer: &mut W) -> std::io::Result<()> {
++        let column_widths = self.get_column_widths();
++        for (i, row) in self.rows.iter().enumerate() {
++            self.print_row(writer, row, &column_widths)?;
++
++            if self.format.borders.internal_h && i < self.rows.len() - 1 {
++                self.print_separator(writer, &column_widths)?;
++            }
++        }
++
++        Ok(())
++    }
++
++    fn print_separator<W: std::io::Write>(
++        &self,
++        writer: &mut W,
++        widths: &[usize],
++    ) -> std::io::Result<()> {
++        if !self.format.row_separator.is_empty() {
++            for (i, width) in widths.iter().enumerate() {
++                if i > 0 {
++                    write!(writer, "{}", self.format.column_separator)?;
++                }
++                write!(writer, "{}", self.format.row_separator.repeat(*width))?;
++            }
++            writeln!(writer)?;
++        }
++        Ok(())
++    }
++
++    fn get_column_widths(&self) -> Vec<usize> {
++        let column_count = self
++            .rows
++            .iter()
++            .map(|row| row.cells.len())
++            .max()
++            .unwrap_or(0);
++
++        let mut widths = vec![0; column_count];
++
++        for row in &self.rows {
++            for (i, cell) in row.cells.iter().enumerate() {
++                let max_line_width = cell
++                    .content
++                    .lines()
++                    .map(strip_ansi_width)
++                    .max()
++                    .unwrap_or(0);
++                let cell_width = max_line_width + cell.padding.0 + cell.padding.1;
++                if i < widths.len() {
++                    widths[i] = widths[i].max(cell_width);
++                }
++            }
++        }
++
++        widths
++    }
++
++    fn print_row<W: std::io::Write>(
++        &self,
++        writer: &mut W,
++        row: &Row,
++        widths: &[usize],
++    ) -> std::io::Result<()> {
++        let cell_lines: Vec<Vec<&str>> = row
++            .cells
++            .iter()
++            .map(|cell| cell.content.lines().collect())
++            .collect();
++
++        let max_lines = cell_lines
++            .iter()
++            .map(|lines| lines.len())
++            .max()
++            .unwrap_or(0);
++
++        for line_idx in 0..max_lines {
++            for (cell_idx, cell) in row.cells.iter().enumerate() {
++                let content_line = cell_lines[cell_idx].get(line_idx).unwrap_or(&"");
++
++                let visible_len = strip_ansi_width(content_line);
++                let left_pad = cell.padding.0;
++                let right_pad = cell.padding.1;
++                let padded_visible = visible_len + left_pad + right_pad;
++
++                let column_width = *widths.get(cell_idx).unwrap_or(&0);
++                let available_space = column_width as i32 - padded_visible as i32;
++
++                // Simple always-left alignment:
++                let align_left = 0;
++                let align_right = if available_space > 0 {
++                    available_space as usize
++                } else {
++                    0
++                };
++
++                let mut line = String::new();
++                line.push_str(&" ".repeat(align_left));
++                line.push_str(&" ".repeat(left_pad));
++                line.push_str(content_line);
++                line.push_str(&" ".repeat(right_pad));
++                line.push_str(&" ".repeat(align_right));
++
++                let final_line = ansi::truncate(&line, column_width);
++                write!(writer, "{}", final_line)?;
++
++                if cell_idx < row.cells.len() - 1 {
++                    write!(writer, "{}", self.format.column_separator)?;
++                }
++            }
++            writeln!(writer)?;
++        }
++        Ok(())
++    }
++}
++
++impl Row {
++    pub fn new(cells: Vec<Cell>) -> Self {
++        Row { cells }
++    }
++}
++
++impl Cell {
++    pub fn new<S: Into<String>>(content: S) -> Self {
++        Cell {
++            content: content.into(),
++            padding: (1, 1),
++        }
++    }
++}
++
++fn strip_ansi_width(s: &str) -> usize {
++    let mut visible_len = 0;
++    let mut in_escape = false;
++
++    for c in s.chars() {
++        if c == '\x1B' {
++            in_escape = true;
++            continue;
++        }
++        if in_escape {
++            if c == 'm' {
++                in_escape = false;
++            }
++            continue;
++        }
++        visible_len += 1;
++    }
++    visible_len
++}
+ is this MR any good?

# 2025-03-20 02:25:06.095475
+Y

# 2025-03-20 02:25:58.761977
+/exit

# 2025-03-20 02:44:56.420283
+/exit
